---
apiVersion: source.toolkit.fluxcd.io/v1
kind: HelmRepository
metadata:
  name: grafana-alloy
  namespace: infra
spec:
  interval: 30m
  url: https://grafana.github.io/helm-charts
---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: alloy
  namespace: infra
spec:
  chart:
    spec:
      chart: alloy
      sourceRef:
        kind: HelmRepository
        name: grafana-alloy
        namespace: infra
  interval: 30m
  install:
    createNamespace: true
  targetNamespace: infra
  releaseName: alloy
  values:
    ingress:
      enabled: true
      hosts:
      - collector-p.zhaohai.li
      faroPort: 12345
      tls:
      - hosts:
        - "*.zhaohai.li"
    crds:
      create: true
    rbac:
      create: true
    serviceAccount:
      create: true
    configReloader:
      enabled: true
    controller:
      type: 'daemonset'
      replicas: 1
      podAnnotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "12345"
        prometheus.io/path: "/metrics"
    service:
      enabled: true
    serviceMonitor:
      enabled: false

    alloy:
      mounts:
        varlog: true
      extraEnv:
      - name: NODE_NAME
        valueFrom:
          fieldRef:
            fieldPath: spec.nodeName
      configMap:
        create: true
        content: |
          logging {
            level  = "info"
            format = "logfmt"
          }

          prometheus.remote_write "default" {
            endpoint {
              url = "http://mimir.infra.svc:9009/api/v1/push"
              headers = {
                "X-Scope-OrgID" = "anonymous",
              }
            }
          }

          prometheus.remote_write "app" {
            endpoint {
              url = "http://mimir.infra.svc:9009/api/v1/push"
              headers = {
                "X-Scope-OrgID" = "app",
              }
            }
          }

          // discovery rules
          discovery.kubernetes "pods" {
            role = "pod"
          }

          discovery.kubernetes "endpoints" {
            role = "endpoints"
          }

          discovery.kubernetes "endpointslices" {
            role = "endpointslice"
          }

          discovery.kubernetes "ingresses" {
            role = "ingress"
          }

          discovery.kubernetes "nodes" {
            role = "node"
          }

          // infra monitor
          discovery.relabel "pod_scrape_infra" {
            targets = discovery.kubernetes.pods.targets

            rule {
              action        = "keep"
              source_labels = ["__meta_kubernetes_pod_node_name"]
              regex         = sys.env("NODE_NAME")
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_node_name"]
              target_label  = "instance"
            }

            rule {
              action = "drop"
              source_labels = ["__meta_kubernetes_namespace"]
              regex = "^default$"
            }

            rule {
              action = "keep"
              source_labels = ["__meta_kubernetes_pod_annotationpresent_prometheus_io_scrape"]
              regex = "^true$"
            }

            rule {
              action = "replace"
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
              target_label = "__metrics_path__"
            }

            rule {
              action = "replace"
              source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
              separator = ":"
              target_label = "__address__"
              regex = "^([0-9.]+)([:0-9]*):([0-9]+)$"
              replacement = "$1:$3"
            }

            rule {
              target_label  = "__name_filter_regex__"
              replacement  = ".*"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_name_filter_regex"]
              regex         = "(.+)"
              target_label  = "__name_filter_regex__"
              replacement  = "$1"
            }
          }

          prometheus.scrape "infra" {
            targets = discovery.relabel.pod_scrape_infra.output
            forward_to = [prometheus.relabel.infra.receiver]

            scheme = "http"
            scrape_interval = "30s"
          }

          prometheus.relabel "infra" {
            forward_to = [prometheus.remote_write.default.receiver]

            rule {
              source_labels = ["__name__", "__name_filter_regex__"]
              regex         = "\\1;.*"
              action        = "keep"
            }
          }

          // app monitor
          discovery.relabel "pod_scrape_app" {
            targets = discovery.kubernetes.pods.targets

            rule {
              action        = "keep"
              source_labels = ["__meta_kubernetes_pod_node_name"]
              regex         = sys.env("NODE_NAME")
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_node_name"]
              target_label  = "instance"
            }

            rule {
              action = "keep"
              source_labels = ["__meta_kubernetes_namespace"]
              regex = "^default$"
            }

            rule {
              action = "keep"
              source_labels = ["__meta_kubernetes_pod_annotationpresent_prometheus_io_scrape"]
              regex = "^true$"
            }

            rule {
              action = "replace"
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
              target_label = "__metrics_path__"
            }

            rule {
              action = "replace"
              source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
              separator = ":"
              target_label = "__address__"
              regex = "^([0-9.]+)([:0-9]*):([0-9]+)$"
              replacement = "$1:$3"
            }

            rule {
              target_label  = "__name_filter_regex__"
              replacement  = ".*"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_name_filter_regex"]
              regex         = "(.+)"
              target_label  = "__name_filter_regex__"
              replacement  = "$1"
            }
          }

          prometheus.scrape "app" {
            targets = discovery.relabel.pod_scrape_app.output
            forward_to = [prometheus.relabel.app.receiver]

            scheme = "http"
            scrape_interval = "30s"
          }

          prometheus.relabel "app" {
            forward_to = [prometheus.remote_write.default.receiver]

            rule {
              source_labels = ["__name__", "__name_filter_regex__"]
              regex         = "\\1;.*"
              action        = "keep"
            }
          }

          // cadvisor
          discovery.relabel "cadvisor" {
            targets = discovery.kubernetes.nodes.targets

            rule {
              action        = "keep"
              source_labels = ["__meta_kubernetes_node_name"]
              regex         = sys.env("NODE_NAME")
            }

            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              target_label  = "instance"
            }

            rule {
              source_labels = ["__address__"]
              target_label  = "__address__"
              regex         = "(.*):.*"
              replacement   = "${1}:10250"
            }

            rule {
              target_label = "__metrics_path__"
              replacement  = "/metrics/cadvisor"
            }
          }

          prometheus.scrape "cadvisor" {
            targets = discovery.relabel.cadvisor.output
            forward_to = [prometheus.relabel.cadvisor.receiver]

            scrape_interval = "30s"
            scheme = "https"
            tls_config {
                server_name = sys.env("NODE_NAME")
                ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                insecure_skip_verify = false
            }
            bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
          }

          prometheus.relabel "cadvisor" {
            forward_to = [prometheus.remote_write.default.receiver]

            rule {
              source_labels = ["__name__"]
              regex         = "^(container_cpu_usage_seconds_total|container_memory_working_set_bytes|container_network_receive_bytes_total|container_network_transmit_bytes_total|container_fs_usage_bytes|container_fs_limit_bytes|container_spec_cpu_quota|container_spec_cpu_period|container_spec_memory_limit_bytes|container_threads|container_file_descriptors)$"
              action        = "keep"
            }

            rule {
              source_labels = ["container"]
              regex         = "POD"
              action        = "drop"
            }

            rule {
              regex  = "^(id|image_id|container_id|job)$"
              action = "labeldrop"
            }
          }

          // kubelet
          discovery.relabel "kubelet" {
            targets = discovery.kubernetes.nodes.targets

            rule {
              action        = "keep"
              source_labels = ["__meta_kubernetes_node_name"]
              regex         = sys.env("NODE_NAME")
            }

            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              target_label  = "instance"
            }

            rule {
              source_labels = ["__address__"]
              target_label  = "__address__"
              regex         = "(.*):.*"
              replacement   = "${1}:10250"
            }

            rule {
              target_label = "__metrics_path__"
              replacement  = "/metrics"
            }
          }

          prometheus.scrape "kubelet" {
            targets = discovery.relabel.kubelet.output
            forward_to = [prometheus.relabel.kubelet.receiver]

            scrape_interval = "30s"
            scheme = "https"
            tls_config {
                server_name = sys.env("NODE_NAME")
                ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                insecure_skip_verify = false
            }
            bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
          }

          prometheus.relabel "kubelet" {
            forward_to = [prometheus.remote_write.default.receiver]

            rule {
              source_labels = ["__name__"]
              regex         = "^(kubelet_.*_pods.*)$"
              action        = "keep"
            }

            rule {
              source_labels = ["container"]
              regex         = "POD"
              action        = "drop"
            }

            rule {
              regex  = "^(id|image_id|container_id|job)$"
              action = "labeldrop"
            }
          }

          // logging
          discovery.relabel "logs" {
            targets = discovery.kubernetes.pods.targets

            rule {
              source_labels = ["__meta_kubernetes_pod_node_name"]
              regex         = sys.env("NODE_NAME")
              action        = "keep"
            }

            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              target_label  = "k8s_namespace_name"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_node_name"]
              target_label  = "k8s_node_name"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_controller_kind"]
              target_label  = "k8s_controller_kind"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_controller_name"]
              target_label  = "k8s_controller_name"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
              separator     = ";"
              regex         = "(.*);(.*)"
              target_label  = to_lower("k8s_${1}_name")
              replacement   = "${2}"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_name"]
              target_label  = "k8s_pod_name"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_container_name"]
              target_label  = "k8s_container_name"
            }

            rule {
              source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_name", "__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
              separator     = ";"
              regex         = "(.*);(.*);(.*);(.*)"
              replacement   = "/var/log/pods/${1}_${2}_${3}/${4}/*.log"
              target_label  = "__path__"
            }
          }

          local.file_match "logs" {
            path_targets = discovery.relabel.logs.output
          }

          loki.source.file "pods" {
            targets    = local.file_match.logs.targets
            forward_to = [loki.process.logs.receiver]
          }

          loki.process "logs" {
            stage.cri {}
            forward_to = [loki.write.local.receiver]
          }

          loki.source.kubernetes_events "events" {
            log_format = "json"
            forward_to = [loki.write.local.receiver]
          }

          loki.write "local" {
            endpoint {
              url = "http://loki.infra.svc:3100/loki/api/v1/push"
            }
          }

